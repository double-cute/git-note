1.快进式推送：

  a.首先需要克隆远程版本库：git clone 远程.git地址 [工作区]
*.如果不包含[工作区]则会默认赋值远程.git的工作区，否则将.git版本库放在指定的工作区中

  b.推送：git push [origin] [分支引用]
    i.首先要知道推送给谁，当用git clone和远程建立关系后，就会把远程的.git地址自动写入.git/config文件中，位于remote origin下
    ii.git默认将远程节点命名为origin，它就代表远程节点的地址
    iii.上面的命令就是指将指定分支推送给远程origin版本库

  c.快进式推送：是指上一次从远程获取代码到现在修改完推送代码过程中，远程版本库一直没有推进（更新），因此这样的推送是快进式的
*.如果在这个过程中，远程版本库向前推进（推进了若干新版本），那么这样的推送就是非快进式
    i.快进式推送永远不会发生冲突，永远都会成功！
    ii.而非快进式推送直接会被拒绝！因为可能会发生潜在的冲突，除非你强制非快进式推送：git push -f
    iii.强制非快进式推送会直接覆盖冲突的版本，并不会自动合并，因此是非常危险的，会导致开发战争！
    iv.因此git服务器端（hub）应该主动拒绝非快进式推送（在服务器端执行）：git config receive.denyNonFastForwards true
*.这样的话，即使客户端git push -f强制推送也会被拒绝！！

  d.推送的本质：分为两步，第一步是服务器端接受推送，推送的版本接受为一临时分支，第二步是将该临时分支合并到目标分支上

  e.如果有人比你先推送，那你推送的时候必然会发生非快进式推送


2.解决非快进式推送：拉回后解决冲突（git pull/git fetch/git merge）

  a.解决非快进式推送最简单、最直观也是最正确的思路就是把非快进推送变成快进式推送

  b.按照这个思路，那问题就很简单了，解决办法就是先获取最新的远程版本，然后将获取的版本和要推送的版本合并后再推送，这样的话，新的推送版本就直接继承于远程版本，即快进式推送了
*.如果在上述过程中，又有其他人抢先你一部推送成功了，那你就只能再重复上述过程了！

  c.直接拉回：git pull [origin] [分支引用]
    i.该命令其实是两步命令的合并：git fetch + git merge
    ii.即先拉回origin的最新版本，然后自动将该版本和目前要推送的版本合并成新的推送版本
  
  d.git fetch的用法：git fetch [origin] [分支引用]
    i.该命令将远程的最新版本分支克隆到本地，并开辟一个临时的"origin/分支引用"的分支保存它
    ii.例如：git fetch origin master之后，本地会多出一个临时分支origin/master，里面暂存着刚刚拉取的分支

  e.git merge的用法：git merge 提交引用或ID列表
    i.该命令会自动将指定提交合并到当前分支
    ii.会以提交前的当前分支作为第一个父提交，列表中从左到右的提交作为第二、第三...父提交

  f.git push origin master  ==   git fetch origin master   +   git merge origin/master
*.origin/master是fetch下载后暂存的隐藏分支，默认命名就是这样的
