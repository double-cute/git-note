1.可以在网上自由传播的cherry-pick――补丁：
  
  a.之前更新远程仓库往往需要先pull再push，但设想，如果是一个超庞大的项目，真正的权威版本库的push权限只可能掌握在少数项目发起者或者管理者的手里：
    i.这就意味着可能百分之99%的普通参与者无权向权威版本库进行推送，那这样的话不就失去了开源社会化编程的意义了吗？
    ii.对于这种项目，普通参与者如果想贡献代码往往需要将自己的修改先发送给管理者审阅，审阅通过后再交由管理者进行最后的推送，这种管理方式非常科学
*.可以有效提高代码质量，同时也不会让权威版本库因为太多人的提交变得杂乱无章
    iii.但是这种组织方式最大的问题是参与者的代码修改应该如何审阅？首先肯定不能讲参与者自己完整的版本库推送给管理者来审阅
    iv.首先这样做非常麻烦，流量大，并且并且直接推送版本库的做法并不能让审阅者快速精确定位到你修改的内容
    v.因此补丁交互就应运而生了！

  b.之前讲过的git cherry-pick其实就是补丁的前生：
    i.每一次提交其实都是对上一版本代码所作出的修改，那么这种修改就可以形象地理解为上一个版本的补丁了
    ii.每次cherry-pick应用一个已有的提交其实就是打一次补丁
    iii.那cherry-pick的局限在于分拣只能在本地进行，不能将已有的提交直接cherry-pick到远程（作为补丁打到远程分支上）
    iv.基于这个需求，git就提供了一个补丁功能，允许将本地已有的提交构造成补丁文件，并且这种补丁文件可以在网上随意传播
    v.补丁文件中有对代码修改的详细说明，并且可以附以补丁功能的说明，审阅者可以根据这些信息快速高效地审阅
    vi.最重要的是git还提供了打补丁的功能，可以像cherry-pick一样把一个补丁应用到当前版本库中

  c.总结：补丁的特点
    i.等价于一个cherry-pick提交
    ii.可以随意传播，传递方便
    iii.补丁内容可以快速定位代码修改，并且具有功能描述信息
    iv.是社会化编程的利器


2.创建补丁：git format-patch -s
  
  a.git format-patch -s <commit-left>..<commit-right>
    i.将按照时间顺序提交的连续的left到right的提交打成补丁
    ii.-s是将作者的姓名添加到补丁说明中，这虽然没什么，但这是作者唯一露脸的机会，如果你不是那么无私的话还是报上姓名比较好
    iii.left和right中间的连续两点..是git命令中表示范围的操作符，类似中文的~  

  b.命令会为每个提交创建一个补丁，每个补丁的命名风格：
    i.会显示序号0001、0002等，序号作为前缀
    ii.补丁名其实就是提交说明的字符串将空格换成-
    iii.例如：git commit -m "fix info bug"转换成补丁就是0001-fix-info-bug.patch
*.最前面的序号按照left-right从左到右递减

  c.补丁其实是一个文本文件（脚本文件），可以用文本编辑器打开查看，里面有对代码修改的描述，git提供命令直接运行脚本来打补丁

  d.应用补丁（打补丁）：git am
    i.补丁创建完之后可以通过任何介质传递：邮件、U盘等等的一切
    ii.应用补丁：git am 补丁名.patch.mbox列表
    iii.am其实是apply mbox的缩写，因为最初git补丁的初衷就是用邮件来传递，而在Linux中邮件附件的格式都是.mbox
    iv.因此应用补丁的命令其实是直接将邮件附件.mbox格式的补丁先转码成正常.patch然后再应用补丁
    v.但考虑到可能很多人没有在控制台操作邮箱的习惯，其实邮箱客户端可能更好用，因此需要一些特殊处理
    vi.特殊处理后应用补丁命令变成：cat 补丁名.patch列表 | git am
*.应用一下管道即可
*.git am可以一次打多个补丁，打补丁的顺序按照补丁序号从小到大依次进行
    vii.示例：cat *.patch | git am
    viii.打补丁的过程其实就是一个个“cherry-pick”


2.变基rebase的实质――补丁：
 
  a.之前讲过的git rebase，是把(left, right]临时保存，在后面变基中一个个cherry-pick的

  b.而其实用的是补丁，因为补丁更加高效，它吧(left, right]创建成临时补丁（即一个补丁列表），然后变基时一个个git am上去
*.最后补丁打完后再将那个临时补丁列表删除
