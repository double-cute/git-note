1.三种分支模式：

  a.发布分支（Release Branch，也称作为Bugfix）：
    i.分布分支建立在一个稳定发布版本之上，例如：v1.0、v2.0、v3.0之列的稳定发布版本
    ii.当版本正式上线交付用户使用之后再在该版本上建立Release Branch分支
    iii.因为一个软件是不停更新发展的，当稳定正式版本发布之后后面必定还会继续开发带有新功能的新版本，不肯能停滞不前
    iv.但不过版本上线之后用户总会发现一些bug需要修正，但此时开发人员已经正在着手开发下一个版本的内容了
    v.但这些bug都是上一个版本中出现的，你不可能把这些bug修正后合并到现在正在开发的下一个版本中，因为：
      *1.用户发现的bug必须立马修正，否则严重影响用户体验，因此不可能等到下一个版本发布之后再让用户体验到那个bug的修正
      *2.下一个版本还需要很长时间才能上线，不可能直接把Bugfix合并到当前正在开发的下个版本中
      *3.就如平常所见，你正在使用一款产品，当前正是版本是v1.0，那么后面随着各种补丁和bug修正仍然处于v1.x这个版本下
      *4.所以需要为每个正是发布版本建立一个发布分支，就是专门用来为这个正是版本打补丁、修bug用的
      *5.通常某个正是版本（vn.0）的发布分支命名为（vn.x）
    vi.发布分支要解决的问题：
      *1.修改用户提交的bug形成新的发布版本并推送给用户继续使用
      *2.千万别忘了，将发布分支上修改bug的提交拣选到当前正在开发的下个版本的分支上
**.因为发布分支是基于上一个正式版本建立的，而当前正在开发的下个版本的分支中还没有对这些bug的修改
    v.发布版本的思路就是可以让发布版的修正和下一个版本的开发同时进行，增加开发效率（多线运行）

  b.特性分支（功能分支，Feature Branch）：
    i.顾名思义就是为了增加某一新特性而专门开一个分支去开发它
    ii.这样做的好处就是，如果该特性是试验性的或者大胆性的，那么即使代码改坏了也不会影响主分支
    iii.其次就是如果该特性开发时间太长或者说临时要撤掉那也会非常简单，设想，如果特性开发和主线开发是在一条线上的，两者混杂在一起，如果有一天要撤掉这个特性那该是多麻烦啊！
    iv.当特性分支开发完后再合并或者分拣到主分支上也不迟

  c.卖主分支（Vendor Branch）：
    i.出现在基于第三方框架上搭建的工程
    ii.考虑到第三方框架的代码也可能会更新（即上游更新），为了避免框架更新和当前开发合并所带来的各种麻烦需要建立卖主分支
    iii.卖主分支建立在工程起始的时候，为当时空的工程（只有第三方框架）建立一个分支，专门用来更新上游代码
    iv.上游代码没更新一次就分拣到当前开发的分支中
    v.特性分支有时往往是采用变基的手段和主分支合并，因为变基比合并少一次提交（合并多一个合并提交）
*.由于正规化开发中要求对每一次提交都进行审核，少一次提交就意味着少一次审核，能大大加大效率，并且变基的历史图要比合并的历史图好看得多


2.查看分支：git branch
*.罗列出当前版本库中所有分支，并且在当前所处的分支前用*标识出来


3.创建分支：git branch <branchname> [<start-point>]
  i.基于某个提交点（提交ID或者引用）创建一个分支
  ii.如果<start-point>省略则默认基于当前HEAD
  iii.创建分支的同时切换到新创建的分支上：git checkout -b <new_branch> [<start_point>]


4.删除分支：git branch -d | -D <branchname>
  i.-D表示强制删除
  ii.-d会检查分支时候合并过，如果还未合并则拒绝删除（毕竟删掉一个没有用过的分支是非常不合理的）


5.分支重命名：git branch -m | -M <oldbranch> <newbranch>
  i.-m会检查新名称是否已经存在（发生冲突），如果冲突则拒绝改名
  ii.-M是强制重命名，会直接覆盖冲突分支