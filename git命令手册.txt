*.git命令中所有的字符串（下面用str_作为前缀的字符串值）如果不包含空格可以直接裸写，包含空格需要用""引起来
*.git默认使用vi作为其编辑器


1.查看git的版本：git --version









11.检出（HEAD指向分支游标，分支游标指向该分支最新的版本提交，但实际上HEAD可以指向任意提交节点，如果HEAD指向了非分支游标则发生“断头”的情况）：git checkout

  a.git reset的主要功能是移动分支游标（即master以及其他branch），而git check的主要功能就是移动HEAD游标（指向不同的分支游标），即切换当前分支（同时覆盖工作区或stage）

  b.检出文件（不会改变HEAD指针，特点就是还原指定的几个文件到工作区）：git checkout [<提交ID或引用>] [--] <文件路径列表>
    i.该命令最重要的特征就是具有文件路径
    ii.如果提交ID或引用的这项[]省略则表示将指定的若干文件从stage还原到工作区，相当于撤销当前工作区文件的修改
    iii.如果提交ID或引用这项[]不省略，则表示从该ID的版本库中将指定文件同时还原到stage和工作区
    iv.示例：
git checkout -- go.c   #将工作区的go.c还原成stage中的
git checkout HEAD^ -- go.c do.c   #将上一个版本的go.c和do.c还原到当前stage和工作区
git checkout -- .   #将整个工作区都还原成和stage一样！相当危险，其实整个git checkout命令也是相当危险的，因为会直接覆盖当前工作区的修改，并且覆盖后数据无法找回

  c.检出分支（切换分支）：git checkout [<分支名>]
    i.该命令的主要特点是没有文件路径了
    ii.该命令会切换HEAD指向指定的分只游标
    iii.并且会用指定分支的最新版本覆盖stage和工作区，即完全和指定分支的最新版本干净、一致的状态
    iv.执行该命令的前提是必须保证当前工作区和stage干净（即没有任何更新，stage相对于当前版本、工作区相对于staged），否则报错拒绝执行
    v.如果省略分支名则默认分支为HEAD，即git checkout == git checkout HEAD，这并不表示用当前版本还原stage和工作区，仅仅就是显示当前工作区、stage和HEAD的差异，不做任何改变
    vi.示例：
git checkout   #检查当前工作区、stage和HEAD的差异
git checkout HEAD   #同上
git checkout other_branch   #HEAD切成other_branch，同时用other_branch的最新版本覆盖当前stage和工作区
！那应该如何用HEAD来覆盖当前stage和工作区呢？很简单，git reset --hard即可


12.保存进度日后慢聊：git stash

  a.如果你现在正工作了一般，突然接到一个紧急任务要求你在另一个分支上修改一个bug（可能命令你在1小时之内改完），那现在问题来了，我当前完成了一般的任务就不得不中止待之后完成了，因此需要保存当前的任务
*.首先不能提交当前的任务，因为该任务你只完成了一半，只有已经完成了一个阶段（可以测试运行了之后）才能提交（这是规矩）
*.其次，你也不能不保存当前任务直接切到修改bug的分支上！不仅情理上不容（直接丢弃当前任务），而且法力上也不容，因为如果当前工作区和stage都有内容的话直接git checkout other_branch命令是拒绝执行的

  b.幸好可以使用git stash命令将当前工作区和stage中的进度先暂时保存起来，进度保存后工作区和stage就干净了（并不是删除了，而是保持和HEAD一样了，用git status发现all clear），接着再checkout切换到其它分支就可以顺利进行了

  c.保存当前进度：
    i.git stash [save str_comment]   #保存进度的同时也可以对本次保存的进度做一些说明
    ii.示例：
git stash   #直接保存当前进度（工作区和stage）
git stash save "music module haven't done yet"   #保存进度的同时对该进度做一些标注（该进度中音乐模块还未完成）

  d.查看进度列表：git stash list
    i.结果显示格式是一行中：stash@{<n>}:当时保存的分支名:进度说明
    ii.n表示最近的第n个保存的进度，按照FIFO的顺序，后保存的先显示
    iii.如果当时保存时自己用save选项做了说明则会在list命令中看到该说明
    iv.如果没有用save选项对保存的进度作说明可以看到默认的说明是merge操作（stash底层是通过两次提交的merge实现对进度保存的，一次是保存工作区的提交，一次是保存stage的提交，最终将这两个提交合并放在元数据库中）

  e.还原进度（还原后将相应的进度从git stash list中删除）：git stash pop [--index] [<stash>]
    i.默认值还原工作区，--index还会还原stage，因为stage是保存在refs/index文件中的
    ii.如果没有[<stash>]则默认从最近保存的一个进度还原，否则从指定的进度还原，[<stash>]即stash@{<n>}，可以参考git stash list的结果
    iii.示例：
git stash pop   #还原stash@<0>，只还原工作区，不还原stage
git stash pop --index stash@<1>   #还原上上个进度，同时还原stage和工作区

  f.还原进度（和pop一样，只不过不删除git stash list中的相应进度）：git stash apply [--index] [<stash>]

  g.删除某个进度：git stash drop [<stash>]
*.默认删除最近的一个进度

  h.删除list中所有的进度：git stash clear


13.打标签（快照）：git tag
  
  a.打标签的同时做出说明：git tag -m str_comment 标签名

  b.查看当前版本与最近一次标签的距离：git describe


14.往stage中添加修改后的文件：git add
  
  a.手动逐个显示添加：git add 文件列表

  b.一次性自动将所有工作区的修改（只有被跟踪的文件）添加到stage中：git add -u
 
  c.一次性自动将所有工作区的修改（包括跟踪和未跟踪的）添加到stage中：git add  -A


15.删除工作区的文件：git rm

  a.用法和Shell的rm一样，它完成两步，第一步在工作区中删除指定文件，第二步将删除这一修改动作添加到stage中

  b.如果用Shell rm掉工作区文件，那么还必须将该文件git add到stage才行

  c.当然最严谨的还是将工作区、stage和版本库的操作隔离开，先Shell rm工作区内容，再add，最后commit，但如果rm的文件特别多，那git add还要再抄一遍，很麻烦，还好有git add -u

  d.示例：
git rm a.txt b*c.txt   #支持通配符，工作区删除的同时也添加到stage
rm *.txt; git add -u   #上述一条命令的分解


16.移动（重命名）：git mv

  a.使用方法和Shell的mv一样，和git rm一样也是同时完成两步，第一步是移动工作区文件，第二步是将移动的操作添加到stage中

  b.git mv old new等价于git rm old; git add new;

  c.git对git mv的跟踪能力强大，如果对一个文件同时进行移动和修改操作，git可以将这两个操作合并，在status只显示一个点rename更新：
示例：git mv old new;  echo "new line" >> new;   git add -A;   git status会只显示一个renamed: old -> new，但是提交后可以看到old和new之间内容差异百分比

  d.注意：直接使用Shell mv后的新文件不会被git跟踪，但是git mv只有的新文件会和git mv操作一并加到stage中，因此git mv后的新文件一定会被跟踪的


17.忽略跟踪：.gitignore

  a.里面记录着让git忽略跟踪的文件，特别是那些编译产生的中间文件.o .lib等，一旦被忽略，那么git add、git status等都追踪不到了
 
  b.只要记录在.gitignore中的文件都将被git忽略，不管怎么git add、git add -A之类的都无法将其加入stage
*.除非使用强制跟踪，即git add -f 文件列表，其中-f是force的缩写，该命令可以将.gitignore忽略的文件强行加入stage
*.一旦加入stage，则文件就被git跟踪了，一旦被跟踪了，那么.gitignore对其的忽略将会无效，比如删了它在使用普通的git add也可以成功添加
*.因此.gitignore只对未被跟踪过的文件有效，一旦被跟踪了，.gitignore就无效了！

  c.强制查看工作区中哪些文件还未被跟踪：git status --ingored
！加-s可以简化显示，其中??表示未被.gitignore忽略但是还未被跟踪的，而!!表示被.gitignore忽略的
！最常用的还是git status --ignored -s

  d.忽略的模式以及范围：
    i.如果.gitignore放在工作区除.git的任意位置，那就是共享式的，该忽略的作用范围为本本版库（不会作用到其它版本库）
    ii.首先，.gitignore文件自己本身也会被git追踪，一旦被追踪就会显示出其共享的特点，即push、pull的时候也会传递.gitignore文件，那么别人或者是你对忽略的设置也会在远程或者本地生效
*.除非将.gitignore自己也忽略，即把.gitignore也记录在.gitignore中

    iii.与共享对应的就是独享，独享有两种形式：
      *1.局部独享：vim .git/info/exclude，该exclude文件就是.gitignore，作用范围就是其所处的版本库，不会影响其他版本库
      *2.全局独享：git config --global core.excludesfile .gitignore的路径，通过该命令将.gitignore放在其它任意一个地方，并且是全局有效的（对本机的所有版本库都生效）
      *3.示例：git config --global core.excludesfile /home/me/.gitignore

  e.忽略语法：
    i.一行一条忽略，可以使用正则表达式：*（0个或多个）、?（一个）、[abc]范围等等
    ii.空行以及以#开头的注释将被忽略
    iii.如果以/开头，则表示只忽略此目录下的文件，但不会递归地忽略其子文件中的内容
    iv.如果以/结尾，则表示忽略此目录下的所有内容（会递归忽略其子目录）
    v.以!其实表示不忽略
    vi.示例：
#comment
*.a
!lib.a       #忽略*.a但不忽略其中的lib.a
/TODO        #之忽略TODO下的文件，但其子目录不忽略
build/       #忽略构建目录中的所有文件
doc/*.txt    #之忽略odc下的所有txt文件


18.归档：git archive

  a.直接对工作区归档会遇到种种麻烦，比如把中间文件等也归档了，还有一些git配置文件也会被归档，而这些都不是我们想要的，我们只想把源代码归档

  b.git archive命令只会把本文库中的目录树归档

  c.zip格式归档：git archive -o 输出归档文件名 版本库中目录树的引用 [该目录下想归档的文件或目录列表]
    i.如果最后[]不写，则默认将整个目录树归档
    ii.示例：git archive -o latest_module.zip HEAD^ src doc   #将上一版本的src和doc目录一并归档到latest_module.zip

  d.tar格式归档（需要外界辅助，git本身并没有内置tar归档器）：git archive --format=tar 目录树引用 | gzip > 输出归档文件名
    i.目录树引用也可以是tag标签
    ii.示例：git archive --format=tar v1.0 | gzip > foo-1.0.tar.gz


19.git支持的网络协议：

   a.SSH：[user@]example.com[:port]:path/.git/

   b.HTTP[S]：http[s]://example.com[:port]/path/.git/

   c.GIT：git://example.com[:port]/path/.git/

   d.FTP[S]：ftp[s]://example.com[:port]/path/.git/

   e.本地：file:///path/.git/


20.快进式推送：

  a.首先需要克隆远程版本库：git clone 远程.git地址 [工作区]
*.如果不包含[工作区]则会默认赋值远程.git的工作区，否则将.git版本库放在指定的工作区中

  b.推送：git push [origin] [分支引用]
    i.首先要知道推送给谁，当用git clone和远程建立关系后，就会把远程的.git地址自动写入.git/config文件中，位于remote origin下
    ii.git默认将远程节点命名为origin，它就代表远程节点的地址
    iii.上面的命令就是指将指定分支推送给远程origin版本库

  c.快进式推送：是指上一次从远程获取代码到现在修改完推送代码过程中，远程版本库一直没有推进（更新），因此这样的推送是快进式的
*.如果在这个过程中，远程版本库向前推进（推进了若干新版本），那么这样的推送就是非快进式
    i.快进式推送永远不会发生冲突，永远都会成功！
    ii.而非快进式推送直接会被拒绝！因为可能会发生潜在的冲突，除非你强制非快进式推送：git push -f
    iii.强制非快进式推送会直接覆盖冲突的版本，并不会自动合并，因此是非常危险的，会导致开发战争！
    iv.因此git服务器端（hub）应该主动拒绝非快进式推送（在服务器端执行）：git config receive.denyNonFastForwards true
*.这样的话，即使客户端git push -f强制推送也会被拒绝！！

  d.推送的本质：分为两步，第一步是服务器端接受推送，推送的版本接受为一临时分支，第二步是将该临时分支合并到目标分支上

  e.如果有人比你先推送，那你推送的时候必然会发生非快进式推送


21.解决非快进式推送：拉回后解决冲突（git pull/git fetch/git merge）

  a.解决非快进式推送最简单、最直观也是最正确的思路就是把非快进推送变成快进式推送

  b.按照这个思路，那问题就很简单了，解决办法就是先获取最新的远程版本，然后将获取的版本和要推送的版本合并后再推送，这样的话，新的推送版本就直接继承于远程版本，即快进式推送了
*.如果在上述过程中，又有其他人抢先你一部推送成功了，那你就只能再重复上述过程了！

  c.直接拉回：git pull [origin] [分支引用]
    i.该命令其实是两步命令的合并：git fetch + git merge
    ii.即先拉回origin的最新版本，然后自动将该版本和目前要推送的版本合并成新的推送版本
  
  d.git fetch的用法：git fetch [origin] [分支引用]
    i.该命令将远程的最新版本分支克隆到本地，并开辟一个临时的"origin/分支引用"的分支保存它
    ii.例如：git fetch origin master之后，本地会多出一个临时分支origin/master，里面暂存着刚刚拉取的分支

  e.git merge的用法：git merge 提交引用或ID列表
    i.该命令会自动将指定提交合并到当前分支
    ii.会以提交前的当前分支作为第一个父提交，列表中从左到右的提交作为第二、第三...父提交

  f.git push origin master  ==   git fetch origin master   +   git merge origin/master
*.origin/master是fetch下载后暂存的隐藏分支，默认命名就是这样的


22.合并以及冲突解决：git merge

  a.git的merge非常智能，对于以下情况都可以实现自动合并，无需人工打开文件对比修改后实现无冲突合并：
    i.不同文件中的修改
    ii.同一文件中的不同位置的修改
    iii.文件移动（其实就是重命名）、文件添加、文件删除等

  b.无法自动合并的冲突：会直接报错，拒绝合并，要求用户自己决定如何修改后再合并
    i.同体冲突：同一文件的相同地方的修改（这是显然的，也是最容易想到的）
    ii.树冲突：目录中同一个结点在两个版本中错位，一个版本的某个目录移动到另一个位置，这样的话两个版本的该目录就在不同位置了，那么合并时应该合并到什么位置呢？肯定没有什么中间位置的，这种冲突也需要用户自己定夺了
*.如果合并成功会自动提交一个新的合并后的版本，当然你也可以不提交，只要加--no-commit选项就行：git merge --no-commit 提交列表
*.之后再自己仔细检查stage中内容确定后再commit，这样更加严谨
    
  c.同体冲突解决：
    i.首先不管合并失败还是成功，该命令都会将已经成功完成合并的文件放入stage中，如果最终合并成功会提交并刷新stage
    ii.如果没有合并成功，那除了冲突文件，其余合并成功的文件仍然已保存在stage中了，只会把没有解决冲突的文件放在工作区中
    iii.只不过合并失败不会提交合并而已
    iv.如果合并失败，会在失败信息中显示出那些没有解决冲突的文件，git会将这些文件做一些特殊标记放在工作区中待用户自己解决冲突
    v.这些文件会用<<<<<<========>>>>>>符号标记出无法解决冲突的部分让用户自行修改，用户修改完成之后再git add、git commit便能完成最后的合并

  d.树冲突解决：
    i.说白了就是文件重命名冲突，当两个版本都对同一个文件重命名后，合并时git必然不能替你做出决定
    ii.一旦发生了树冲突双方就必须要讨论如何解决冲突以及合并
    iii.一般两个人的商量结果无非就是两种情况：
      *1.最简单的情况，取其一，删除其中一个留下另一个，这样的合并可以直接通过git命令快速解决
      *2.最麻烦的情况，需要两者取中和，可能会是两者的命名加起来的结果，这就需要手动改文件之后合并了
    iv.树冲突合并失败后（git pull & git merge）必然会出现这样的情况：A的重命名文件和B的重名文件同时出现在工作区和stage，同时两者命名之前的文件出现在stage中，也就是说stage会出现三个
    v.如果解决的方法仅仅是两者取其一，那么只要将舍弃的和重名之前的文件git rm掉，把要留下的那个文件git add掉，最后commit掉就完成合并了，之后push即可
*.这种手工的方法不仅仅可以解决树冲突，而且可以解决同时发生内容修改冲突的树冲突
    vi.同样，仅仅是两者取其一也可以使用命令行工具，git mergetool，发生冲突后直接输入命令git mergetool之后，会列出所有冲突的文件，然后根据提示逐一选择如何处理即可，非常无脑
   
  e.无法依靠git解决的冲突――逻辑冲突：即逻辑bug
    i.上述的所有情形即使是无法解决的冲突git也会提示你解决
    ii.但是某些逻辑上的冲突确实没法按照上面套路解决的，比如头文件问题，一个人改了头文件的名称推送，另一个人改了实现文件合并，没有问题，因为改动的是不同文件
    iii.但是头文件名改动后，所有引用它的实现文件中头文件名也需要该，虽然git不会报冲突，但是你工程编译的时候就会报错，而这里问题git没法解决，只能由项目经理特别注意，制定好机制来避免！
*.冲突解决后别忘了commit，提交之后就可以push了
